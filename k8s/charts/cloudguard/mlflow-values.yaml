# k8s/charts/cloudguard/mlflow-values.yaml

# 1. Enable S3 for Artifacts
artifactRoot:
  s3:
    enabled: true
    bucket: "cloudguard-sentinel-datalogs-surabhi"

# 2. Configure the Service Account
serviceAccount:
  create: true
  name: "mlflow-server"
  annotations:
    eks.amazonaws.com/role-arn: "arn:aws:iam::447646782725:role/cloudguard-app-pod-role"

# 3. PostgreSQL Settings
postgresql:
  enabled: true
  image:
    registry: public.ecr.aws
    repository: bitnami/postgresql
    tag: "16"
  auth:
    username: "mlflow"
    password: "mlflow-password"
    database: "mlflow"
  # RAMDISK MODE (optional, for better performance)
  primary:
    persistence:
      enabled: true
      size: 8Gi
      storageClass: "gp2"

# We explicitly set the image repo here just to be safe, but more importantly, we override the COMMAND
image:
  repository: ghcr.io/mlflow/mlflow
  tag: v2.14.1
  pullPolicy: IfNotPresent

# Set the command
command:
  - "/bin/bash"
  - "-c"
  - "pip install psycopg2-binary boto3 && mlflow server \"$@\""
  - "--"

# Memory and CPU settings
resources:
  limits:
    cpu: 1000m
    memory: 1024Mi
  requests:
    cpu: 250m
    memory: 512Mi

# Service & Port Settings
service:
  type: ClusterIP
  port: 5000
  targetPort: 5000

# Readiness and Liveness Probe Settings
readinessProbe:
  initialDelaySeconds: 300
livenessProbe:
  initialDelaySeconds: 300

# Connect MLFLOW to PostgreSQL and S3
# We construct the connection strings here using the sub-chart's DNS names.
# The format is: postgresql://[user]:[password]@[release-name]-postgresql:5432/[db_name]
extraArgs:
  host: "0.0.0.0"
  port: "5000"
  # Note: 'mlflow' is the release name we use in the helm command below
  backend-store-uri: "postgresql://mlflow:mlflow-password@mlflow-stack-postgresql:5432/mlflow"
  default-artifact-root: "s3://cloudguard-sentinel-datalogs-surabhi/"
